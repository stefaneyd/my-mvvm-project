#summary One-sentence summary of this page.

= Introduction =
In this module we are going to discuss the !ModelViewViewModel otherwise known as the MVVM design pattern. The !ModelViewViewModel design pattern facilitates modern development techniques such as separation of concerns, unit testing and test driven development. As with most design patterns the !ModelViewViewModel design pattern is just a set of guidelines that when you follow them it makes it easier to write applications. Use them where they makes sense and modify them to fit the needs of your application at a given point in time.
  * Where did MVVM come from?
  * What is MVVM?
  * Components of MVVM
  * Implementation

= History =
  * 2004 Martin Fowler - Presentation Model (PM)
    * Separates a view from it's state and behavior
    * Not dependent on a specific UI framework
In 2004 a gentleman named Martin Fowler published an article that describes a design pattern called the presentation model. In this article he explains that the Presentation Model design pattern is similar to the MVP or the Model View Presenter pattern in that it separates a view from its behavior and state. Specifically the Presentation Model pulls the state and behavior out of the view and into a model class. It coordinates with the domain layer and provides an interface to the view. The presentation model frequently updates its view so that the two stay in sync with each other, that synchronization logic exists as code in the presentation model classes. One thing to note about the presentation model pattern, it is not specific to any UI framework.
  * 2005 John Gossman unveiled the MVVM pattern
    * Variation of MVC pattern
In 2005 a gentleman named John Gossman, who at the time was one of the WPF and Silverlight architects at microsoft, unveiled the !ModelViewViewModel pattern in his blog. In the blog he described the !ModelViewViewModel as a variation of the Model View Controller but its tailored for the modern UI development platforms where the view is the responsibility of a designer rather than a developer.
  * 2008 John changes his mind
    * Identical to PM pattern
    * Dependent on WPF/Silverlight
In 2008 John changes his mind, he realised that the !ModelViewViewModel pattern is identical to Fowlers Presentation Model, and that both patterns feature an abstraction of a view which contains a view state and behavior. Fowler introduced the Presentation Model pattern as a means of creating a UI platform independent abstraction of a view, where as Gossman introduced the !ModelViewViewModel pattern as a standardised way to leverage core features of WPF and Silverlight. Meaning that the !ModelViewViewModel design pattern is tailor made and specific to the WPF and Silverlight platforms.

= Intent =
  * Separate concerns
    * View
    * View's state and behavior
    * Data
  * Unit Testing & UI Testing
  * Maintenance
  * Extensibility
  * Enables the designer/developer workflow
  * Take advantage of WPF/Silverlight data binding
So what exactly does the !ModelViewViewModel design pattern really do for us, for one it helps the developers separate the concerns of the view the view state and behavior and the underlying data. It also allows for unit testing of the application as well as UI testing. Most would agree that maintenance is the number one cost in the software development lifecycle, add a new feature here, add a new feature there, make a change, modify this, modify that. Well we want to be able to do that throughout the entire lifecycle of the application but we don't want to break anything and we want to make it easy to actually implement these features or make those changes. It also helps developers and designers work together with less technical difficulties, in the past there has always been friction between the designers and the developers, you know who is touching my UI and who is touching my code. Well now you can split the two teams more easily, you don't get a lot of that budding heads that you used to get, you know designers can go and create this awesome beautiful user interface without ever having to know what the developer is doing, the designer just needs to know the data points that they are going to exposing to the user and the programmer doesn't have to know what the designer is doing, he doesn't care he is just coding to the functionality of the applications requirements. The single most important aspect that the !ModelViewViewModel pattern relyse on is the data binding infrastructure in WPF and Silverlight.By binding elements of a view to a viewModle you get very loose coupling between the two, and your entirely remove the need for writing code in a views code behind or in a viewModel that would directly update a view. The data binding system also supports input validation, which provides a standardized way of transmitting validation errors to the view.

= Structure =
<img src="http://s4.postimg.org/4gg5e4r59/mvvm_structure.png" width="600px" /><br />
The !ModelViewViewModel design pattern is made up of three components it has a view a viewModel and a model. We will discuss each of these components in more detail later on but for now I want to concentrate on the structure of the pattern.
Lets begin with the view, The view may or may not have a reference to the viewModel it really depends on how you implement this pattern in your applications. When I say that the view does not have a reference to the viewModel I mean that there will not be a hard coded instance created either in the view XAML or in the code behind. There will be an instance, if you will of the viewModel in its !DataContext but that could be set by other mechanisms such as a factory pattern of some type. But at any case the view will never know about the model it should never have a reference to the model. The only component in the MVVM pattern that has a reference to the model will be the viewModel. The !ViewModel may or may not have a reference to the view. Once again it just really depends on how you decide to implement this pattern in your application. If you decide to have the viewModel create the view which is the viewModel first approach, then the viewModel will have a reference to the view, if you decide to go view first approach then the view would have a reference to the viewModel. But once again if you are using a factory pattern it is completely possible that neither one of them have any reference to each other. The model is completely oblivious to the fact that the viewModel and the view even exist. This is a very loosely coupled design which pays dividends in many ways.

= Demo: Creating the Application =
Lets create a simple MVVM application. Lets start off by creating a new Silverlight application and call it !SimpleMvvm, we will not need to create a web site to host this demo application. Now lets create three folders "Models", "!ViewModels" and "Views". Now lets move the !MainPage to the Views folder couse we are going to use that as our main view. Now lets create a model object class and name it "Person" and we are also going to need a viewModel so lets create a class and name it !MainViewModel. Now put the Person class into the Models folder and the !MainviewModel class to the !ViewModels folder. And that is how this project structure should look like at this point.<br />
<img src="http://s24.postimg.org/n1ylgwtut/project_structure.png" />
<br />

= The Model =
<img src="http://s13.postimg.org/ubanyv9t3/the_model.png" width="800px" />
<br />
The model is the data and you can look at the model from two different perspectives, there is the object oriented approach where your model may be represented by domain specific objects, or you can use the data centric approach where your model may be a XML file or a data access layer or anything else that is responsible for communicating with the data store. Either way the models purpose is to represent the data points and it has no knowledge of where it will be presented or how it will be presented. It's singel responsibility is to represent the data points. On the image we have a person object with two properties, this person object implements two interfaces the INotifyPropertyChanged interface which is responsible for notifying the UI or presentation layer of any changes made to a properties value, the IDataErrorInfo interface is used to notify the UI if a validation role has failed against one of those properties.

= Demo: Creating the Model =
We start by giving our person model object some properties that we are going to be binding our UI to. Person normally has a first name, and a last name and at some point we are going to update our person so lets give it a !DateTime property named !UpdatedDate. In order to let my UI know that any of these property values change we are going to have to implement an interface INotifyPropertyChanged. The implementation is simple we are going to have a public method that takes a string parameter.
{{{
public event PropertyChangedEventHandler PropertyChanged;
public void OnPropertyChanged(string property)
{
  if(PropertyChanged != null)
    PropertyChanged(this, new PropertyChangedEventArgs(property));
}
}}}
Now that we have implemented the interface we need to modify our properties so when they do change we can let them know.
{{{
private string _FirstName;
public string FirstName
{
  get { return _FirstName; }
  set
  {
    _FirstName = value;
    
    //Add this code to the properties so we can know when the property changes
    OnPropertyChanged("FirstName");
  }
}
}}}
Now our properties are firing the !PropertyChangedEvent when the value changes. This allows the view to display any changes that have been made to the underlying objects properties. Now we got to worry about something else, we got to worry about validation, how do I send validation errors up to my view? This is accomplished by implementing the IDataErrorInfo interface. For the Error property we are going to return null. This is the objects level error, so we would set this for the objects level validation.
{{{
public string Error
{
  get { return null; }
}
}}}
We are going to keep the validation on our Person object pretty simple, so we are just going to validate that the first name has been entered.
{{{
public string this{string columnName]
{
  get
  {
    string error = string .Empty;

    if(string.isNullOrEmpty(_FirstName))
      error = "First Name is required";

    return error;
  }
}
}}}
Now anytime this validation error fails my UI will be notified thru the IDataErrorInfo interface and send a notification to the user.

*Person class*
{{{
public class Person : INotifyPropertyChanged, IDataErrorInfo 
{
  private string _FirstName
  public string FirstName
  {
    get { return _FirstName; }
    set
    {
      _FirstName = value;
      OnPropertyChanged("FirstName");
    }
  }

  private string _LastName
  public string LastName
  {
    get { return _LastName; }
    set
    {
      _LastName = value;
      OnPropertyChanged("LastName");
    }
  }

  private DateTime _UpdateDate;
  public DateTime UpdateDate
  {
    get { return _UpdateDate; }
    set
    {
      _UpdateDate = value;
      OnPropertyChanged("UpdateDate");
    }
  }

  public event PropertyChangedEventHandler PropertyChanged;
  public void OnPropertyChanged(string property)
  {
    if(PropertyChanged != null)
      PropertyChanged(this, new PropertyChangedEventArgs(property));
  }

  public string Error
  {
    get { return null; }
  }
  public string this{string columnName]
  {
    get
    {
      string error = string .Empty;

      if(string.isNullOrEmpty(_FirstName))
        error = "First Name is required";

      return error;
    }
  }
}
}}}

= The !ViewModel =

<img src="http://s14.postimg.org/rsph57ru9/View_Model.png" width="800px" />
<br />
You may be wondering what exactly goes into a viewModel if my data and its data points are in the model, but the viewModel contains properties commands and other abstractions to facilitate communication between the view and the model. What does this mean? Well it means that the viewModel will have properties that expose instances of your model objects it will also have commands or events that interact with the view to respond to any type of user interaction at a minimum you want your viewModel to implement the INotifyPropertyChanged interface. this is because your view will be bound to your viewModel and the INotifyPropertyChanged interface is the mechanism which pushes data up to the view. As you can see we have a viewModel called !MainViewModel, it exposes a property of type Person, and this is the Person domain object that was in our view slide. We are exposing an instance of that Person object to our view. And any time the Person object instance changes the view will be notified of that change and update accordingly. There has been some debate recently about what your viewModel should inherit from. A lot of people have their viewModels inherit from !DependencyObject or UI element. Although the viewModel manages the state and behaviour of the view it should not have dependency on a UI base object, basicly you do not want any control related objects in your viewModel.

= Demo: Creating the !ViewModel =
Now lets work on our viewModel and open up the !MainViewModel class, at minimum my viewModel has to implement the INotifyrPropertyChanged interface.
{{{
public event PropertyChangedEventHandler PropertyChanged;
public void OnPropertyChanged(string propertyName)
{
  if(PropertyChanged != null)
    PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
}
}}}
Now we have our INotifyPropertyChanged interface implemented and we have to have this at minimum because this is the mechanism that pushes all the changes and our base data up to the view. The next thing I want to do is I want to expose a property that is an instance of my model object.
{{{
private Person _ModelPerson;
public Person ModelPerson
{
  get { return _ModelPerson; }
  set
  {
    _ModelPerson = value;
    OnPropertyChanged("ModelPerson");
  }
}
}}}
And we need to add that !OnPropertyChanged to that property so whenever that property changes it updates the view. And now we need to populate this Person object with an instance of something, so lets first create a constructor for our viewModel and create our Person instance in the constructor so when we create a new instance of our viewModel we create and assign a new instance of our Person object to our !ModelPerson property.
{{{
public MainViewModel()
{
  LoadPerson();
}

private void LoadPerson()
{
  ModelPerson = new Person()
  {
    FirstName = "Brian",
    LastName = "Lagunas"
  };
}
}}}