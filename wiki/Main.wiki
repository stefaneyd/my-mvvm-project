#summary One-sentence summary of this page.

= Introduction =
In this module we are going to discuss the !ModelViewViewModel otherwise known as the MVVM design pattern. The !ModelViewViewModel design pattern facilitates modern development techniques such as separation of concerns, unit testing and test driven development. As with most design patterns the !ModelViewViewModel design pattern is just a set of guidelines that when you follow them it makes it easier to write applications. Use them where they makes sense and modify them to fit the needs of your application at a given point in time.
  * Where did MVVM come from?
  * What is MVVM?
  * Components of MVVM
  * Implementation

= History =
  * 2004 Martin Fowler - Presentation Model (PM)
    * Separates a view from it's state and behavior
    * Not dependent on a specific UI framework
In 2004 a gentleman named Martin Fowler published an article that describes a design pattern called the presentation model. In this article he explains that the Presentation Model design pattern is similar to the MVP or the Model View Presenter pattern in that it separates a view from its behavior and state. Specifically the Presentation Model pulls the state and behavior out of the view and into a model class. It coordinates with the domain layer and provides an interface to the view. The presentation model frequently updates its view so that the two stay in sync with each other, that synchronization logic exists as code in the presentation model classes. One thing to note about the presentation model pattern, it is not specific to any UI framework.
  * 2005 John Gossman unveiled the MVVM pattern
    * Variation of MVC pattern
In 2005 a gentleman named John Gossman, who at the time was one of the WPF and Silverlight architects at microsoft, unveiled the !ModelViewViewModel pattern in his blog. In the blog he described the !ModelViewViewModel as a variation of the Model View Controller but its tailored for the modern UI development platforms where the view is the responsibility of a designer rather than a developer.
  * 2008 John changes his mind
    * Identical to PM pattern
    * Dependent on WPF/Silverlight
In 2008 John changes his mind, he realised that the !ModelViewViewModel pattern is identical to Fowlers Presentation Model, and that both patterns feature an abstraction of a view which contains a view state and behavior. Fowler introduced the Presentation Model pattern as a means of creating a UI platform independent abstraction of a view, where as Gossman introduced the !ModelViewViewModel pattern as a standardised way to leverage core features of WPF and Silverlight. Meaning that the !ModelViewViewModel design pattern is tailor made and specific to the WPF and Silverlight platforms.

= Intent =
  * Separate concerns
    * View
    * View's state and behavior
    * Data
  * Unit Testing & UI Testing
  * Maintenance
  * Extensibility
  * Enables the designer/developer workflow
  * Take advantage of WPF/Silverlight data binding
So what exactly does the !ModelViewViewModel design pattern really do for us, for one it helps the developers separate the concerns of the view the view state and behavior and the underlying data. It also allows for unit testing of the application as well as UI testing. Most would agree that maintenance is the number one cost in the software development lifecycle, add a new feature here, add a new feature there, make a change, modify this, modify that. Well we want to be able to do that throughout the entire lifecycle of the application but we don't want to break anything and we want to make it easy to actually implement these features or make those changes. It also helps developers and designers work together with less technical difficulties, in the past there has always been friction between the designers and the developers, you know who is touching my UI and who is touching my code. Well now you can split the two teams more easily, you don't get a lot of that budding heads that you used to get, you know designers can go and create this awesome beautiful user interface without ever having to know what the developer is doing, the designer just needs to know the data points that they are going to exposing to the user and the programmer doesn't have to know what the designer is doing, he doesn't care he is just coding to the functionality of the applications requirements. The single most important aspect that the !ModelViewViewModel pattern relyse on is the data binding infrastructure in WPF and Silverlight.By binding elements of a view to a viewModle you get very loose coupling between the two, and your entirely remove the need for writing code in a views code behind or in a viewModel that would directly update a view. The data binding system also supports input validation, which provides a standardized way of transmitting validation errors to the view.

= Structure =
<img src="http://s4.postimg.org/4gg5e4r59/mvvm_structure.png" width="600px" /><br />
The !ModelViewViewModel design pattern is made up of three components it has a view a viewModel and a model. We will discuss each of these components in more detail later on but for now I want to concentrate on the structure of the pattern.
Lets begin with the view, The view may or may not have a reference to the viewModel it really depends on how you implement this pattern in your applications. When I say that the view does not have a reference to the viewModel I mean that there will not be a hard coded instance created either in the view XAML or in the code behind. There will be an instance, if you will of the viewModel in its !DataContext but that could be set by other mechanisms such as a factory pattern of some type. But at any case the view will never know about the model it should never have a reference to the model. The only component in the MVVM pattern that has a reference to the model will be the viewModel. The !ViewModel may or may not have a reference to the view. Once again it just really depends on how you decide to implement this pattern in your application. If you decide to have the viewModel create the view which is the viewModel first approach, then the viewModel will have a reference to the view, if you decide to go view first approach then the view would have a reference to the viewModel. But once again if you are using a factory pattern it is completely possible that neither one of them have any reference to each other. The model is completely oblivious to the fact that the viewModel and the view even exist. This is a very loosely coupled design which pays dividends in many ways.

= Demo: Creating the Application =
Lets create a simple MVVM application. Lets start off by creating a new Silverlight application and call it !SimpleMvvm, we will not need to create a web site to host this demo application. Now lets create three folders "Models", "!ViewModels" and "Views". Now lets move the !MainPage to the Views folder couse we are going to use that as our main view. Now lets create a model object class and name it "Person" and we are also going to need a viewModel so lets create a class and name it !MainViewModel. Now put the Person class into the Models folder and the !MainviewModel class to the !ViewModels folder. And that is how this project structure should look like at this point.<br />
<img src="http://s24.postimg.org/n1ylgwtut/project_structure.png" />